const input = `.###.#.#.#..###.##.#.....#.####.####..##.#.##.#....##.###.#..####.##.#.
.###.#...######....##.#..###..#.#.##.#.######..##.#.....#...#.#.##.##..
.##....#..#...#..##.....##......#.#..#......#..#..###..#..##..#.#.##.#.
#####.###.##.#.##.#.#...##.##.#.#..####...#.#..####.#.######.###.######
#...#.#.#####....#.#.###..#####..####.#.#....###.#.####..##..###.####..
#.#.#.#####.....#....##....####.#..#...##.##..##..##..#..#...####.#..##
....#.#..####.#...#........##...##...#.##.##########...###..#####.#...#
.####.#...##.#..##....###.##..#.###.#.##..######.##.#.#.##....##..#....
..#...#...#..#####......#.....#.##..#.####.##...#####..#..###.#..##....
#..#.#.#....####...#..##..#...#..#.#####.#.##..###.#.#.#...#######.#...
.#.#.####....###...#..#.#...#.#.####..#..#........#..###....########.#.
#.##.#.##.#...#.##.###....##...####.###...#.##.##..##....#...####.#..#.
.#.#.#.#..###..#.####..######.##..#.#######...####.#.#.#.##...#.....###
#..###...##......#..#....#..#..##......#####...#.##.....#.###..#...#..#
.####...#.#....###.#.....#.##.#.....##...##.....#..#####..###.##.#.#.##
..#...#.#.#...##########..###.###....#..###....##..#.########.##.#.#.##
####..#..#.####...####..##.##.##....#..###.###.......##.......#.##...##
...#####..#.####.#.#.#.###..#..#..#.##.##..#.###.###.#...#.#.##.....#..
##..###.##.###.##.####.#.#.....##.##.#..###..####..########.###..###.##
#.#.#..#....###.#...#.#...#..###.###..#.##.##.####.##.##.##..#..###..##
#..###.....##.#####.###..##.###.#.....##.#....###..######..##.#.###...#
#.##..##.#.#.#.##.#..##..#..##..#....#..###.......###.####..##...#.#.#.
##...#..##..#.#..##.##...#.#.#..####.#..##...#.#...######....##.#...#..
#.###...#####..####..##..##.###..##.#.####..##.#.###.#.#..#......#.....
.#...#.#.###........#.#.#...#..####...#.#####.#####...#....###.##.###..
....###....####..##..###.##..##.##.#.###.##.#.#.....#.....###.##...##..
#....######.....#.#...#.#..###.....#....#..##.##.###..##....#.###...#..
#.#.#.#.#...#.#.#...#.#.....####.###.#####.#.##..###..#.#####.#......#.
.##.####...######.#.###.##.###..#.##..#.#.#....##.#.#####.#...####....#
.#.#.##..##..###.#.#....####....#......#..##..###..########...#.##.##.#
#.###.##...#....#..###..#......##..#....#.####..#.##..#.##.#.##.#...###
#..#....##.###..###..##..#...#......#..####.#.#.#######.#...#####..#..#
..#.###.#..###.###......#.####..###..#.#..#.#.....##...#..#.#.##.###...
...##.........#..###.##..#######.######....######.#####.#.#.#.#..######
###.##..###.#.####...###..#..#...#...##.#.#......#..#.###..#.#...#....#
...###....##....#.##.#...###....##.#...#..#...#.#.##..#..#..####....#.#
.#.#..#########....#.##.##..#.##..##.###..#.###..##.#..#.####.#.##.##..
##..####..###.#.....#.#.#.##...#.##....##.#.#.....##.....#..##.#.##.##.
#..#.######.#.###...#..#.#.###.##.##.#.###.....#.......####..#...###..#
.##..##.###.#.###.#######.#.#.#.##.#....#...#####....###.######..#..##.
#.####....#..#...###.....###..##...###....##.#..#..##...##..#.####..#..
..###.##.###.#.#....##.####.#.#...#.#####.####..#.#.#.###.##.###...####
##.##..#..##.....#####..####.##.#.#.##..##.#.#..##..#.##.#.#....####...
###.#.#....#...#...#.#...#.#..#.#.###.###.##..#..#..###.##..#.#...##...
...#.....#.##...##....##...##.#.#..#.##.#.#..##.####.#.##..#.......#...
#....####.#.....###.##.#.###.#####.##....#.##..#####.....#.##.##..###.#
.#..#..##.#..##.#.######.##...##...#.##..##..#.#.#..##.#....##...######
....##.##.#...#.###....##..#..#..#..#...#...####.##.########.###..##..#
###...####......#.#..#..#.##.####.#.##.#.##.#..##.#..###..####..#.#.###
..#####...#.#.....#....####.##..##.##..###...##.###..##.####.####..###.
..#.##.##...##..##.#..##.#.###...#.#..##.#.##.###.#.#.#.#.#..#..##.#..#
.#.....#..####..#...#.#..####.#####.#..###.##.###.###.#.......####.##..
.#.#####.#....#..##..#.###.####.#.....#..#.####..#.#.#....#.##.##..###.
.....#...#.#..#.#.#.#.##..####.##.##.###.#......#..#.##...####.#.#.#.#.
##...#..#..##..##..#...#.##.###....#..#..##..#.##.#.###.###.#....#.##..
#.##.##...#.....##...###.#####..###..#.#.#..#.#.....#####.###.#..##...#
.###..#.#.#...###.##...##...#..#.#.#...#.###....###......#.#.###..###.#
###..#...###...#.#.##.#..##.#.....#..##.#..#########..##.#.###.#.#.#...
.##.#.#.#.#...#...##.##..#.##..#########..#.##.###.##.####.#.##.####.##
##.#####...##.....##.....##....###...#....#...#.##.#..##.#...#.#.#...#.
##....#.#....##.##..###....####.#...######.#..##......#.####...#.#.##.#
#####.#...#.....###....#.##....#..#.##.#####.########.###.#..#.##.#..##
##..#.#..##.#.##...#...##.#####.###.####.#...##...###...##..#...###.###
#.##..#....######..#.###.....#.#.####.##..##.##.#####......#.#.###..###
.#####..####.#.##...###.....#######..######.#.##....#..##.##.##.##.#.##
...##.....#.###.####.#.###.#......##.#....#..###.....#.###.......####..
.#.########..#.#...###.#.##....#.##.####.#.##....#.###.#.####.#.#...##.
.###.#.#.#.#..#.##..#####..#######...#...#..######.....###...##.#.##.#.
.#.....##..#.#..##.#.#..#.#..##.#..#...##..######.#.########...###.#...
..###.##..#.##..#........#.#....###..#.....##.##.##..#.##..###.#...#.##
..#.####.######.#......#...###.#...##.#...###.###.#..###.#..##.#..####.`;

const example = `....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..`;

const DEBUG = false;
const N = 'N', S = 'S', W = 'W', E = 'E';
const Ni = 0, Si = 1, Wi = 2, Ei = 3;
let DIR_ORDER = [Ni, Si, Wi, Ei];
let counter = -1;
let elves = input
  .split(/\n/) // split lines
  .map((v,r) => v
    .split('') // split each line per character
    .map((v,c) => v == '#' ? {id: ++counter, pos: [r,c]} : null) // return r,c positions of # chars, else null
    .filter(v => v != null)
  ) // filter out null
  .flat()
  .reduce((p, e) => { p[e.id] = e; return p; } , {}) // flatten into one list
  ;
console.log(elves);
let check_map = Object.values(elves).reduce((p, c) => { p[c.pos[0] + ',' + c.pos[1]] = c; return p; }, {});

console.log(check_map);

const roll_order = (order) => {
  order.push( order.shift() );
  return order;
};

const is_occupied = (pos) => {
  let occupied = check_map[pos[0] + ',' + pos[1]];
  DEBUG && console.log(pos, 'is ' + (!occupied ? 'not' : '') + ' occupied');
  return occupied;
};

const gen_move = (pos, dir) => {
  if (dir == N) {
    // generate NW, N, NE
    let moves = [ [pos[0]-1, pos[1]-1], [pos[0]-1, pos[1]], [pos[0]-1, pos[1]+1] ];
    DEBUG && console.log('N moves: ', moves);
    let valid = moves.filter(v => !is_occupied(v));
    DEBUG && console.log('Valid N Moves: ', valid);
    if (valid.length == 3) {
      return moves[1];
    }
  }
  else if (dir == S) {
    // generate SW, S, SE
    let moves = [ [pos[0]+1, pos[1]-1], [pos[0]+1, pos[1]], [pos[0]+1, pos[1]+1] ];
    DEBUG && console.log('S moves: ', moves);
    let valid = moves.filter(v => !is_occupied(v));
    DEBUG && console.log('Valid S Moves: ', valid);
    if (valid.length == 3) {
      return moves[1];
    }
  }
  else if (dir == W) {
    // generate NW, W, SW
    let moves = [ [pos[0]-1, pos[1]-1], [pos[0], pos[1]-1], [pos[0]+1, pos[1]-1] ];
    DEBUG && console.log('W moves: ', moves);
    let valid = moves.filter(v => !is_occupied(v));
    DEBUG && console.log('Valid W Moves: ', valid);
    if (valid.length == 3) {
      return moves[1];
    }
  }
  else if (dir == E) {
    // generate NE, E, SE
    let moves = [ [pos[0]-1, pos[1]+1], [pos[0], pos[1]+1], [pos[0]+1, pos[1]+1] ];
    DEBUG && console.log('E moves: ', moves);
    let valid = moves.filter(v => !is_occupied(v));
    DEBUG && console.log('Valid E Moves: ', valid);
    if (valid.length == 3) {
      return moves[1];
    }
  }
  return null;
};

const gen_next_move = (pos) => {
  let moves = [
    gen_move(pos, N),
    gen_move(pos, S),
    gen_move(pos, W),
    gen_move(pos, E),
  ];
  DEBUG && console.log('Generated moves', moves);
  if (
      (moves[0] != null && moves[1] != null && moves[2] != null && moves[3] != null) ||
      (moves[0] == null && moves[1] == null && moves[2] == null && moves[3] == null)
    ) {
    return null;
  }
  let dir = DIR_ORDER.find(d => moves[d] != null);
  let move = moves[dir];
  DEBUG && console.log('Next move is', move);
  return move;
};

const run_for = (rounds) => {
  const elves_list = Object.values(elves);
  for (let i = 0; i < rounds; i++) {
    DEBUG && console.log('Round', i+1);
    let proposed_moves = {};
    elves_list.forEach((e, i) => {
      let next_move = gen_next_move(e.pos);
      if (next_move == null) { // all direction is free
        DEBUG && console.log('Elf', e.id, 'does not have to move');
        // don't move
      }
      else if (!proposed_moves[next_move[0] + ',' + next_move[1]]) {
        DEBUG && console.log('Elf', e.id, 'wants to move to', next_move);
        // create entry for this move and add elf
        proposed_moves[next_move[0] + ',' + next_move[1]] = {next: next_move, elves: [e.id]};
      }
      else {
        DEBUG && console.log('Elf', e.id, 'also wants to move to', next_move);
        // add elf to this existing proposed move
        proposed_moves[next_move[0] + ',' + next_move[1]].elves.push(e.id);
      }
    });
    DEBUG && console.log('proposed moves', proposed_moves);
    let list_proposed_moves = Object.keys(proposed_moves);
    if (list_proposed_moves.length > 0) {
      Object.keys(proposed_moves).forEach(m => {
        if (proposed_moves[m].elves.length == 1) { // if only one elf will move then move
          let elf = proposed_moves[m].elves[0];
          let next = proposed_moves[m].next;
          DEBUG && console.log('Elf', elf, 'moving from', elves[elf].pos, 'to', next);
          let old_pos = elves[elf].pos;
          elves[elf].pos = next;
          delete check_map[old_pos[0] + ',' + old_pos[1]];
          check_map[next[0] + ',' + next[1]] = elves[elf];
          DEBUG && console.log('Elf', elf, elves[elf]);
        }
        else {
          DEBUG && console.log('These elves', proposed_moves[m].elves, 'wanted to go to', proposed_moves[m].next, 'but cannot.');
        }
      });
      
    }
    else {
      return console.log('No moves proposed at round', i+1);
    }
    DEBUG && console.log(check_map);
    // rotate
    DIR_ORDER.push( DIR_ORDER.shift() );
    DEBUG && console.log('#################',"\n\n");
  }
};

run_for(10000);
// console.log(elves);
let min_row = Number.MAX_VALUE;
let max_row = Number.MIN_VALUE;
let min_col = Number.MAX_VALUE;
let max_col = Number.MIN_VALUE;
// Find bounding rectangle
Object.values(elves).forEach(e => {
  min_row = Math.min(min_row, e.pos[0]);
  max_row = Math.max(max_row, e.pos[0]);
  min_col = Math.min(min_col, e.pos[1]);
  max_col = Math.max(max_col, e.pos[1]);
});
console.log(min_row, min_col, max_row, max_col);
// compute area(?) - occupied tiles
let empty_ground_tiles = (Math.abs(min_row) + Math.abs(max_row) + 1) * (Math.abs(min_col) + Math.abs(max_col) + 1) - Object.values(elves).length;
console.log('empty ground tiles', empty_ground_tiles);