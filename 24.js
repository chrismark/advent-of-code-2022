const input = `#.####################################################################################################
#.<><^^.^..^v>.v<>v>><^<v>.>^<v<<>^v<^<<^>^vv<>.<^vv<^^v..<v^^.v><vv^v>.^.>><>vv^>^^>>.^v^<<^^^^>^.><#
#<>>v>.<<vv.><^<<>v>^<>>.<<v^<<^<<>><^^<v<^>.><<<><>>^^^>v<^>v>v^>^v>>vv<<v>^<v<<>vv..>vv^.<^^<<vvv><#
#><<.<>v<v>^.v^<^v>v<.>>v^vv.v<<<>>><v<>^v>v<>v.v<.^^^.^<<v^v.<^^<v^^^.^^>^^><.>.v^<^.^<<.><^^^v<^><<#
#<>^>vvvv^.<^.<v<<v>v>>^vv>^.<v<^><>.v<<^^^>^<<v>.^^<.>^.><<v<v^v^vv<v<><^v<vv..<^.^^>^>vv^^<^v>v<<^<#
#.<>>^<^>.^^vv^vvv^^<>><.^v<>^^<v^v^^v<<^^>^<.<.^<v><v^^v>v>^><^>vv>>..^<<>^v.>^<v.<v<>^v<<<<^<>.^><>#
#.<><^<v<^>^v^vv.<^><<v<^<<>^.<..v<v>.>>v>^.<^v><>>.v^<>v>vv>v>v<^v>><v<>^<.<<.><v.<v><<<^.>>v^<.v>>>#
#<^<>>^v><<>>v.vv^>^<^vvv^>^<<^>..v<^^^v>>vvv<<>>^>v>^vvv^>v.>v><<^<<.vv.>>^.^>v<<<v<^^^^<<v><^<v.vv>#
#.v><^^<><>v<>><.^^<^^<v<<>v^>><><v^^<<<.^v^><>^<^^>><>v>>><.<^<v>^.v^^>^^>><>^<vv<^><>^>^>^^v<>vv>v>#
#<^^v>vv^v^vv>^<<^^^^>^>><<<<>.^<^^v<^^>>vv<>^>^^^>>>>v>v<..v>>.>vv^v>vv>v>>.<>v>><>vv<>v<.>.^v^<v^^>#
#<^^v<^>^><>^v>^><.vv^vv><^<v^<>>^<<v<>v>>..^<^vvvv<<><v^<<^v>>..>v.^^><v>v^v^<<<^v.>^<>^v<>><<>>.>..#
#<v.>^^v><.>>v<<>^v>>>v><<<>v.vv^^<vv<v>>>^<^vv>v><<>v^<^^<vvv><v<^v.^>^v^^<<^v.<>>.>>>^vv>.v>v.v<^>.#
#>>v<vv^>>v^v>>><v^^><v><>^<^<<^^<vv>vvv^.^^>>>^<>v<v.^>v><>>^<vv.<><v...^^v>>^v>^v>.>^.>^v<>>.v>><<>#
#<.^^vv<v^.^>><>>v<^<v.^>>>><>>^>>v^vv^v^<^<>^>.^>v><.>>v<v.v>.>v><.^<v.^<<<>v<<^vv<<^<>.^>>^.>.>>^><#
#<^^v<^<>>>v>>v><^v>.>v^.^v^v>^<<>v^^>v^^><v<v.<v^v><<<>v><vv>vv^.><^><.<<>v.>v^^<^<<v<<^><><^v>>v.<<#
#<^v<v^<.^v^><^v><^>>v.v.<<^vv<.^^>.^>^.<..<^^^^.^<^<v^>>v^^.<<^^v.>>^v^>v<v^<^>><<^^<>.><>v..<>^v^.<#
#><<><<v^^<>v>v^v>v^v>^<>.v<^vv<<^<>^>vv<<^v<^v<>.<v>.vv^<>.vv<^.<>v><>^.^^v^v^v<^^.<.^<><<v<v^>>...>#
#>^v^.>^<<v^><.<vv>>^^vv>.<<^>vv^>.<vv^>.^<v^v>^>v^>.vvv><<^v<><<^^^^v^vvv^^^vv^v<v>>v^v><v^<^vv>><.<#
#<>><<.v.>^^^<>^v^^>>^<>v.^<><.^.vv>.>^>^<v<vv^<<^<>>^<.v>>v>><<.vv^vv.>>^v>.^vv<.v>v>vvv>>vv>^><v>^<#
#.^.^^>>^^v>>><>.><^v>>v^^v^.vv><vv<^<<>v>v>>v^v^>v^^<>^v..>^.v^^<^><^v>><>^v>v>>vv^<v<.<>vv.<<<.<<<>#
#>>^<<.v<<<v>>v><^v^vv<<>^vv>^v^v<^v^>>^^^^<^<<>..^>>^^^<v^v<>>vv>v<^<>>.<^<.>.>v<><>>.^>v<.<>^<>>v.<#
#<<v>>>.v>>.^>..<>v^v^vv>>v^<v>^v^v<<^vvv<..><^>>.<<<<>>v.<^^^><v^^<<v>><v^^>>^v>><v>vv^vv>.>^<.><><<#
#<>v<>v>^<v>vvvv^<v><>>^>v<^>^>^<^vvv..^^v><^<^v^<^v<v.<<v.vv>v.>v<v>^^>>^.<v<^^v<^<v^<<>vv^<<.><.^><#
#<.^^v<v<><>><<^>.>^<>><vv^<^^><<>v<v^vv^v^>^v<<v<v<>^>^.<v^..>vv<.^v><.^^>.v>..^..v>vv^>^v>>v^^v>.^>#
#<v><^<v<>^.<<<<><<>v><v.v<^>>.>^v>^>>.^v.<^^>v^<^<^>^<>^>>^^>v<v<>^v<v.^vv^>^<<><>v^<>.v^<<^v<>>^><>#
#<>vvvv><<>^>.>^^^v<<<^v<><<.<^<^.<^^><<v<.<v<vvvv^v^>v>^^<v^>>^v<>^>^^>vv>^^v>^v^><<<>>v>>^.^^>vv..<#
#>^vv>v^^<vv>v^<^.^>v<<^<^^>^.<v>><^^^<>.^<..^<<>v.v<>v>^>^v<.^^<>v>>v^<>v><v<.v>v^vv<.>.<>vv>>>.<>v.#
#<^^vv><<<.<^^^<^v>^<v^^^>>.vv>vvv^.^<<^>v>>^v.>^v><.^v<vvv>v^^v<v<v<^<<^^^<.^<v.^v<<^^v.<v>>^v>vv<>>#
#<><^><><>v>..v^<vv^<^><<>v.>><<^^^^..v^^>>v><^>v>^<<<^<.v^<>v^v>>><..>.v<^>vv^^<^v^.<<^>><^^^vv.^>>>#
#<>>>vv..v<>^>>v^<^v>^.^^<^^^<v>^^>v<<v..<<>v<^>..<>><<>>>>v^v^^v<v>.<<^^^^v>><>^.^<^^vvv><vvv^>^.<..#
#>^><^>^>.>>^^vv.^<.^^>vv<v><^>v^>^vv^v<>^.<<.><^<^<^v^^>^.>^>v<v^^>.>^^vvv^v>>>>v<v<><..<>>><^^^>^<<#
#>>v^.<<^v^.>.v<<<^v>>^.v^<<<<>>v>>><v>...^v^v<>vv.vv..^<vvv^..<.^>v<^<>v.^^v^>.^<v>.v^<>vv.^><^>^^<>#
#>^.^v^<^v<vvv><v>.^<^<^^v^^<<>v^^^..><^v>><.^>v^>>...>^<<>^>^^<v>^v<>v^^>>^>vv^><vv..<>^v.<^^<>^>^<>#
#<>vv>>v^^^>>v>v<^>^v.><<<>v^<<>vvv>^v^^>vv<<^v<>^v...><.<^>^^>v<v>v^<v<<<^>v^<^^v<vvv><.^v>>vvvvvv>>#
#>^v>.vv^vvv>>><<><v^vv<vv.<v><v><^>>>><.v^..>>.<>>v>>>>^<<^<>^^.<v^v<<vv>^v.>v>.<^^^.^<^^<v>^v<><.>>#
#>>.<.vv>.^<v>^.<vvv^^>^^<>^><v>^^^>>>v^v<>^v<>>v>^v>v.^^vv<.<>>.v.v><v^.>v^>^<<.v<><^v<^>v^v>^vvv.<<#
####################################################################################################.#`;

const example1 = `#.#####
#.....#
#>..^.#
#.....#
#...v.#
#.....#
#####.#`;

const example2 = `#.######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#`;

const GRID = example2
  .split(/\n/)
  .map(v => v.split(''))
  ;
// console.log(GRID);

const NROWS = GRID.length;
const NCOLS = GRID[0].length;
const START = [0, 1];
const END = [GRID.length - 1, GRID[0].length - 2];
const BOUNDARY_ROW_START = 0;
const BOUNDARY_ROW_END = GRID.length - 1;
const BOUNDARY_COL_START = 0;
const BOUNDARY_COL_END = GRID[0].length -1;
const available_each_minute = [];
let blizzards = {};
let positions = {};
let copy_blizzards = null;
let copy_positions = null;
const dead_ends = {};
const R = '>', L = '<', U = '^', D = 'v';
let E = [0, 1];
let copy_E = E.slice();
let counter = 0;

const add_to_position = (pos_key, id) => {
  if (!positions[pos_key]) {
    positions[pos_key] = {__count: 0};
  }
  positions[pos_key][id] = true;
  positions[pos_key].__count++;
};

const remove_from_position = (pos_key, id) => {
  if (positions[pos_key]) {
    delete positions[pos_key][id];
    positions[pos_key].__count--;
    if (positions[pos_key].__count == 0) {
      delete positions[pos_key];
    }
  }
};

GRID.forEach((row, ri) => row.forEach((e, ci) => {
  if (e == R || e == L || e == U || e == D) {
    let id = ++counter;
    blizzards[id] = {id: id, pos: [ri, ci], dir: e};
    add_to_position(ri + ',' + ci, id);
  }
}));
console.log(START, END);
// console.log(blizzards);
// console.log(positions);
copy_blizzards = JSON.parse(JSON.stringify(blizzards));
copy_positions = JSON.parse(JSON.stringify(positions));

const calc_distance = (coord1, coord2) => {
  return Math.abs(coord1[0] - coord2[0]) + Math.abs(coord1[1] - coord2[1]);
};

const get_blizzard = (r, c) => {
  return positions[r + ',' + c];
};

const is_boundary_collision = (pos, dir) => {
  return (
    (dir == R && pos[1] == BOUNDARY_COL_END) ||
    (dir == L && pos[1] == BOUNDARY_COL_START) ||
    (dir == U && pos[0] == BOUNDARY_ROW_START) ||
    (dir == D && pos[0] == BOUNDARY_ROW_END)
  );
};

const move = (b, rewind = false) => {
  // if (rewind) { console.log('Rewinding'); }
  // console.log('blizzard', b);
  let old_pos_key = b.pos[0] + ',' + b.pos[1];
  // console.log('old_pos_key', old_pos_key);
  if ((!rewind && b.dir == R) || (rewind && b.dir == L)) {
    b.pos[1]++;
    if (is_boundary_collision(b.pos, b.dir)) { 
      // wrap
      b.pos[1] = BOUNDARY_COL_START + 1;
    }
  }
  else if ((!rewind && b.dir == L) || (rewind && b.dir == R)) {
    b.pos[1]--;
    if (is_boundary_collision(b.pos, b.dir)) { 
      // wrap
      b.pos[1] = BOUNDARY_COL_END - 1;
    }
  }
  else if ((!rewind && b.dir == U) || (rewind && b.dir == D)) {
    b.pos[0]--;
    if (is_boundary_collision(b.pos, b.dir)) { 
      // wrap
      b.pos[0] = BOUNDARY_ROW_END -1;
    }
  }
  else if ((!rewind && b.dir == D) || (rewind && b.dir == U)) {
    b.pos[0]++;
    if (is_boundary_collision(b.pos, b.dir)) { 
      // wrap
      b.pos[0] = BOUNDARY_ROW_START + 1;
    }
  }
  let new_pos_key = b.pos[0] + ',' + b.pos[1];
  // console.log('new_pos_key', new_pos_key);
  add_to_position(new_pos_key, b.id);
  remove_from_position(old_pos_key, b.id);
};

const display = (show = true) => {
  let line = '';
  let empty_positions = [];
  for (let i = 0; i < NROWS; i++) {
    for (let j = 0; j < NCOLS; j++) {
      if (i == BOUNDARY_ROW_START) {
        if (i == E[0] && j == E[1]) {
          line += 'E';
        } 
        else if (i == START[0] && j == START[1]) {
          line += '.';
        }
        else {
          line += '#';
        }
      }
      else if (i == BOUNDARY_ROW_END) {
        if (i == E[0] && j == E[1]) {
          line += 'E';
        } 
        else if (i == END[0] && j == END[1]) {
          empty_positions.push({pos: [i,j], score: 0});
          line += '.';
        }
        else {
          line += '#';
        }
      }
      else if (j == BOUNDARY_COL_START || j == BOUNDARY_COL_END) {
        line += '#';
      }
      else {
        let bs = get_blizzard(i,j);
        // console.log('bs', bs);
        if (!bs) {
          if (i == E[0] && j == E[1]) {
            line += 'E';
          }
          else {
            empty_positions.push({pos: [i,j], score: 0});
            line += '.';
          }
        }
        else if (bs.__count == 1) {
          if (i == E[0] && j == E[1]) {
            line += '!';
          }
          else {
            line += blizzards[Object.keys(bs)[0]].dir;
          }
        }
        else if (bs.__count > 1) {
          if (i == E[0] && j == E[1]) {
            line += '!';
          }
          else {
            line += bs.__count;
          }
        }
      }
    }
    line += "\n";
  }
  if (show) console.log(line);
  return empty_positions;
};

/**
If elves move like blizzard

  if (!(up.pos[0] == END[0] && up.pos[1] == END[1]) && up.pos[0] == BOUNDARY_ROW_START) {
    up.pos[0] = BOUNDARY_ROW_END - 1;
  }
  if (!(down.pos[0] == END[0] && down.pos[1] == END[1]) && down.pos[0] == BOUNDARY_ROW_END) {
    down.pos[0] = BOUNDARY_ROW_START + 1;
  }
  if (!(left.pos[0] == END[0] && left.pos[1] == END[1]) && left.pos[1] == BOUNDARY_COL_START) {
    left.pos[1] = BOUNDARY_COL_END - 1;
  }
  if (!(right.pos[0] == END[0] && right.pos[1] == END[1]) && right.pos[1] == BOUNDARY_COL_END) {
    right.pos[1] = BOUNDARY_COL_START + 1;
  }

 */
const get_possible_moves = (from) => {
  let up = {pos: [from[0] - 1, from[1]], dir: U};
  let down = {pos: [from[0] + 1, from[1]], dir: D};
  let left = {pos: [from[0], from[1]-1], dir: L};
  let right = {pos: [from[0], from[1]+1], dir: R};
  let moves = [];
  
  if ((up.pos[0] == END[0] && up.pos[1] == END[1]) || up.pos[0] > BOUNDARY_ROW_START) {
    moves.push(up);
  }
  if ((down.pos[0] == END[0] && down.pos[1] == END[1]) || down.pos[0] < BOUNDARY_ROW_END) {
    moves.push(down);
  }
  if ((left.pos[0] == END[0] && left.pos[1] == END[1]) || left.pos[1] > BOUNDARY_COL_START) {
    moves.push(left);
  }
  if ((right.pos[0] == END[0] && right.pos[1] == END[1]) || right.pos[1] < BOUNDARY_COL_END) {
    moves.push(right);
  }

  return moves;
};

const get_candidate_moves = (possible_moves, empty_positions, minute) => {
  let moves = possible_moves
    .map(m => empty_positions.find(p => m.pos[0] == p.pos[0] && m.pos[1] == p.pos[1]))
    .filter(e => e)
    // TODO: Not only check position BUT ALSO the current minute
    .filter(e => dead_ends[e.pos[0] + ',' + e.pos[1]] == undefined || dead_ends[e.pos[0] + ',' + e.pos[1]][minute] == undefined)
    .sort((a,b) => a.score - b.score)
    ;
    
  if (moves.length == 2) {
    if (moves[0].pos[1] > moves[1].pos[1]) {
      moves = [moves[0]];
    }
    else {
      moves = [moves[1]];
    }
  }
  
  return moves;
};

const run_for = (n, wait_for) => {
  // let paths = [
  //   { positions: [E], found_end: false }
  // ];
  let E_path = [E];
  let i = 0;
  let empty_positions = null;
  let possible_moves = null;
  let candidate_move = null;
  // display();
  while (i < n) {
    console.log('minute', i, 'E =', E);
    Object.values(blizzards).forEach(b => move(b));
    empty_positions = display(false);
    if (wait_for != undefined && wait_for <= 0) {
      empty_positions = empty_positions.map(v => { v.score = calc_distance(v.pos, END); return v; });
      // console.log(empty_positions);

      /*
      let temp = null;
      paths.forEach((p,i) => {
        console.log(i);
        // console.log('p', p);
        if (p.found_end) { return; }
        let last_pos = p.positions[p.positions.length - 1];
        let possible_moves = get_possible_moves(last_pos);
        let candidate_moves = get_candidate_moves(possible_moves, empty_positions);
        // console.log('candidates', candidate_moves);
        if (candidate_moves.length == 0) {
          p.positions.push(last_pos.slice());
        }
        else if (candidate_moves.length == 1) {
          let new_paths = [JSON.parse(JSON.stringify(p))];
          new_paths[0].positions.push(candidate_moves[0].pos);
          if (Array.isArray(temp)) {
            temp = [...temp, ...new_paths];
          }
          else {
            temp = new_paths;
          }
        }
        else if (candidate_moves.length > 1) {
          let new_paths = new Array(candidate_moves.length).fill().map(v => ({positions: p.positions.slice(), found_end: false}));
          // console.log('Before new_paths', JSON.stringify(new_paths));
          candidate_moves.forEach((m, i) => {
            // console.log('candidate move', i, m, 'append to', JSON.stringify(new_paths[i]));
            new_paths[i].positions.push(m.pos);
            if (m.pos[0] == END[0] && m.pos[1] == END[1]) {
              new_paths[i].found_end = true;
            }
          });
          // console.log('After new_paths', JSON.stringify(new_paths));
          if (Array.isArray(temp)) {
            temp = [...temp, ...new_paths];
          }
          else {
            temp = new_paths;
          }
        }
      });
      if (temp) {
        paths = temp;
        temp = null;
      }
      */

      // console.log('paths', JSON.stringify(paths));
      possible_moves = get_possible_moves(E);
      // console.log('possible_moves', possible_moves);
      candidate_move = get_candidate_moves(possible_moves, empty_positions, i);
      // console.log('candidate_move', candidate_move);
      // console.log('E', E);
      if (candidate_move.length > 0) {
        E = candidate_move.shift().pos.slice();
        E_path.push(E);
        // console.log('E', E);
        /*
        do {
          E = candidate_move.shift().pos.slice();
          if (!dead_ends.has(E[0] + ',' + E[1])) {
            break;
          }
          else {
            E = null;
          }
        } while (candidate_move.length > 0);
        console.log('E', E);

        if (E != null) {
          E_path.push(E);
        }
        else {
          console.log('You will share a position with a blizzard in a future position', E);
          E = E_path.pop();
          dead_ends.add(E[0] + ',' + E[1]);
          E = E_path[E_path.length - 1];
          Object.values(blizzards).forEach(b => move(b, true));
          Object.values(blizzards).forEach(b => move(b, true));
          console.log('previous E', E);
          i--;
          continue;        
        }
        */
        // if (dead_ends.has(E[0] + ',' + E[1])) {
        //   E = E_path.pop();
        //   Object.values(blizzards).forEach(b => move(b, true));
        //   console.log('You will share a position with a blizzard in a future position', E);
        //   console.log('previous E', E);
        //   i--;
        //   continue;
        // }
        // else {
          
        // }
        
      }
      else { // == 0
        // console.log('E', E);
        let bs = get_blizzard(E[0], E[1]);
        if (bs) {
          // display();
          console.log('You are sharing a position with a blizzard', E, bs, blizzards[Object.keys(bs)[0]]);
          if (wait_for == undefined) {
            if (!dead_ends[E[0] + ',' + E[1]]) {
              dead_ends[E[0] + ',' + E[1]] = {__count: 1};
              dead_ends[E[0] + ',' + E[1]][i] = true;
              console.log('initialized', dead_ends[E[0] + ',' + E[1]]);
            }
            else {
              console.log('matched', dead_ends[E[0] + ',' + E[1]]);
              if (dead_ends[E[0] + ',' + E[1]].__count >= 1) {
                let keys = Object.keys(dead_ends[E[0] + ',' + E[1]]).filter(key => key != '__count').map(k => parseInt(k)).sort((a,b) => a-b);
                console.log('Keys', keys);
                if (keys.length >= 1) {
                  if (!dead_ends[E[0] + ',' + E[1]][keys[0] - 1]) {
                    dead_ends[E[0] + ',' + E[1]][keys[0] - 1] = true;
                    dead_ends[E[0] + ',' + E[1]].__count++;
                  }
                  if (!dead_ends[E[0] + ',' + E[1]][keys[0]]) {
                    dead_ends[E[0] + ',' + E[1]][keys[0]] = true;
                    dead_ends[E[0] + ',' + E[1]].__count++;
                  }
                }
              }
              else {
                // TODO: Might not be needed
                dead_ends[E[0] + ',' + E[1]][i].__count++;
              }
            }       
            // dead_ends[E[0] + ',' + E[1]][i-1] = true;
            // dead_ends[E[0] + ',' + E[1]][i-2] = true;
            console.log('Adding to dead ends', E, 'at minutes', i, i-1);
            // E_path.pop();
            // E = E_path[E_path.length - 1];
            // console.log('previous E', E);
            // console.log('Rewinding');
            // Object.values(blizzards).forEach(b => move(b, true));
            // Object.values(blizzards).forEach(b => move(b, true));
            // display();
            // i--;
            // continue;
          }
          return i;
        }
        else {
          console.log('You are free to not move from', E);
        }
      }
      // console.log('E', E);
      // let paths_found_end = paths.filter(p => p.found_true);
      // if (paths_found_end.length > 0) {
      //   console.log('All paths found end.');
      //   return found;
      // }
      // display();
      // console.log("\n");
    }
    else if (wait_for != undefined) {
      console.log('Waiting', wait_for);
      wait_for--;
    }
    if (E[0] == END[0] && E[1] == END[1]) {
      console.log('Found End');
      // break;
      return true;
    }
    i++;
  }
  // return paths;
};

for (let i = 0; i < 500; i++) {
  let found = run_for(10000, i);
  if (found === true) { break; }
  else {
    console.log('minute', found, 'E =', E);
    display();
    E = copy_E.slice();
    blizzards = JSON.parse(JSON.stringify(copy_blizzards));
    positions = JSON.parse(JSON.stringify(copy_positions));
    console.log(dead_ends);
    console.log('Retry', "\n");
  }
}

// console.log(JSON.stringify(paths));